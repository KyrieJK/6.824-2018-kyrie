# 分布式系统基础理论(三)	ACID和BASE理论

   * [分布式系统基础理论(三)	ACID和BASE理论](#分布式系统基础理论三acid和base理论)
      * [具体业务场景](#具体业务场景)
      * [分布式一致性的提出](#分布式一致性的提出)
      * [BASE理论](#base理论)
      * [ACID理论](#acid理论)
         * [事务的具体定义](#事务的具体定义)
         * [数据库本地事务](#数据库本地事务)
      * [小结](#小结)

## 具体业务场景

上一篇文章中已经讲到了CAP定理，在计算机科学领域，分布式一致性是一个相当重要且被广泛探索与论证的问题。下面可以通过三个场景再看一下对于分布式一致性的需求。

1. 火车站售票

   用户去火车站购票，出票后拿着票去检票上车。假设在同一时刻不同售票窗口的另外一位乘客也购买了同一张车票。假如说售票系统没有进行强一致性保障，两人有可能都会购票成功。而在检票口检票的时候，其中一位乘客会被告知他的车票无效。这只是为了说明一致性而举的例子，现在的售票网站基本不会出现这种情况。

2. 银行转账

   一位用户去银行转账，柜员在完成转账操作后通知用户，“转账将在一个工作日后到账”。这时我们首要关心的是数据一致性，至于需要花费多长时间完成转账操作是次要的。

3. 网上购物

   假设我们在网上购物，当看到库存量为1的商品后，会迅速的确认下单购买，然而在进行下单的操作时，系统可能会通知该用户商品库存量不足。此时绝大部分用户都会认为是自己的动作太慢，才会被其他人抢走。其实真正的原因是在商品页上显示的库存量并不是真正的库存量，当用户真正下单的时候，系统才会检查商品真正的库存量。

对于上面的三种场景，不同业务系统对于数据一致性的需求是不同的。

1. 有些业务系统，既要快速响应客户，同时还要保证系统的数据对于任意客户端都是真实可靠的，就像火车站售票系统
2. 有些业务系统需要为客户保证绝对可靠的数据一致，虽然在数据一致性的过程中存在延时，但最终务必保证严格的一致性，就像银行的转账系统
3. 有些业务系统，虽然向用户展示了一些不一致的数据，但是在整个系统使用过程中，一定会在某一个流程上对系统数据进行准确无误的检查，从而避免用户发生不必要的损失。

## 分布式一致性的提出

在分布式系统中要解决的一个重要问题就是数据的复制。在日常开发过程中，我们偶尔会遇到这样的问题：假设客户端C1将系统中的一个值K由V0更新为V1，但是客户端C2无法立即读取到K的最新值，需要在一段时间后才能读取到。这是因为数据复制过程中存在延时。

分布式系统对于数据的复制需求一般都来自于以下两个原因：

1. 为了增加系统的可用性，以防止单点故障引起的系统不可用
2. 提高系统的整体性能，通过负载均衡技术，能够让分布在不同地方的数据副本都能够为用户提供服务

那么如何解决数据不一致所带来的问题？

其中的一种思路是既然是由于延时动作引起的问题，那我可以将写入的动作阻塞，直到数据复制完成后，才完成写入动作。一些场景的系统架构采用的正是这种思路，但是这个方案在解决数据一致性问题的同时，又带来了系统性能的问题：写入的性能。如果你的业务场景有非常多的写请求，那么使用这个方案将会导致后续的写请求都将会阻塞在前一个请求的写操作上，导致系统整体性能下降严重。

我们无法找到一种能够完美满足分布式系统所有特性的一种方案，所以在数据一致性和系统可用性上，我们在设计分布式系统时需要重点权衡的点。正是如此，一致性级别才从此诞生。

## BASE理论

BASE理论就是对CAP定理中一致性和可用性权衡的结果。BASE是Basically Available(基本可用)、Soft State(软状态)和Eventually consistent(最终一致性)。BASE理论是来源于大规模互联网系统分布式实践的总结，是基于CAP定理逐步演进而来，它的核心思想是：即使无法做到强一致性，但是每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。

BASE理论的三要素：

1. 基本可用

   基本可用是指分布式系统在出现故障的时候，允许损失部分可用性。与正常系统比较而言：

   - 响应时间上的损失：正常情况下的搜索引擎0.5s即返回给用户结果，而基本可用的搜索引擎可以在2s中返回结果。
   - 功能上的损失：在一个电商网站上，正常情况下，用户可以顺利完成每一笔订单。但是到了大促期间，为了保护购物系统的稳定性，部分消费者可能会被引导到一个降级页面。

2. 软状态

   相对于原子性而言，要求多个节点的数据副本都是一致的，这是一种“硬状态”。

   软状态是指允许系统中的数据存在中间状态，并认为该状态不影响系统的整体可用性，即允许系统在多个不同节点的数据副本存在数据延时。

3. 最终一致性

   上面提到的软状态，只是允许系统中的数据存在一段时间的中间态。不可能这部分数据一直处于中间状态，必须有个时间期限。在时间期限到后，应当保证所有副本保持数据一致性，从而达到数据的最终一致性。这个时间期限取决于网络延时、系统负载、数据复制方案设计等因素。

   在实际工程中，最终一致性又分为5种：

   - 因果一致性(Causal consistency)：如果节点A在更新完某个数据后通知了节点B，那么节点B之后对该数据的访问和修改都是基于A更新后的值。同时，和节点A无因果关系的节点C的数据访问则没有这样的限制。
   - 读己之所写(Read your writes)：节点A更新一个数据后，它自身总是能访问到自身更新过的最新值，而不会看到旧值。其实这也算是一种因果一致性。
   - 会话一致性(Session consistency)：将对系统数据的访问过程限制在一个会话当中，系统能保证在同一个有效的会话中实现读己之所写的一致性，也就是说执行update操作后，客户端能够在同一个会话中时钟读取到该数据项的最新值。
   - 单调读一致性(Monotonic read consistency)：如果一个节点从系统中读取出一个数据项的某个值，那么系统对于该节点后续的任何数据访问都不应该返回更旧的值。
   - 单调写一致性(Monotonic write consistency)：一个系统要能够保证来自同一个节点的写操作被顺序的执行。

   实际上，不只是分布式系统使用最终一致性，关系型数据库在某些功能上也使用最终一致性。比如备份，数据库的复制过程是需要时间，这个复制过程中，业务读取的值就是旧值。当然最终还是达成了数据一致性。



## ACID理论

ACID是在RDBMS中事务所具有的的四个特性：Atomicity、Consistency、Isolation、Durability。

### 事务的具体定义

事务提供一种机制将一个活动涉及的所有操作纳入到一个不可分割的执行单元，组成事务的所有操作只有在所有操作均能正常执行的情况下才能提交，只要其中任一操作执行失败，都会导致整个事务的回滚。简单来说，事务提供一种“要么什么都不做，要么做全套”的机制。

### 数据库本地事务

数据库事务中的四大特性：ACID

- 原子性（Atomicity）

  一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被rollback到事务开始前的状态，就像这个事务从来没有执行过一样。

- 一致性（Consistency）

  事务的一致性指的是在一个事务执行之前和执行之后数据库都必须处于一致性状态。如果事务成功地完成，那么系统中所有变化将正确地应用，系统处于有效状态。如果事务中出现错误，那么系统中的所有变化将自动地回滚，系统返回到原始状态。

- 隔离性（Isolation）

  在并发环境中，当不同的事务同时操作相同的数据时，每个事务都有各自的完整数据空间。由并发事务所做的修改必须与任何其他并发事务所做的修改进行隔离。事务查看数据更新时，数据所处的状态要么是另一事物修改它之前的状态，要么是另一事务修改它之后的状态，事务不会看到中间状态的数据。

  多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果。事务最复杂的问题都是由事务隔离性引起的。完全的隔离性是不现实的，完全的隔离性要求数据库同一时间只执行一条事务，这样会严重影响数据库性能。因此不完全的隔离性就会导致在事务并发执行中发生的许多问题：

  - 脏读：事务A读取了事务B更新的数据，然后事务B回滚操作，那么A读取到的数据是脏数据
  - 不可重复读：事务A多次读取同一数据，事务B在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致。
  - 幻读：事务A对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，事务B也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作事务A的用户发现表中还剩余有没有修改的数据行，就好像发生了幻觉一样。
  - 第一类丢失更新(Lost Update):在没有事务隔离的情况下，两个事务都同时更新一行数据，但是第二个事务却中途失败退出，导致对数据的两个修改都失效了。
  - 第二类丢失更新(Second lost update)：不可重复读的特殊情况。有两个并发事务同时读取同一行数据，然后其中一个对它进行修改提交，而另一个也进行了修改提交。这就会造成第一次写操作失效。

  为此数据库设置了四个事务隔离等级，来解决不同的并发问题：

  - READ_UNCOMMITTED(读未提交)：事务中的修改，即使没有提交，在其他事务也都是可见的。该级别只能解决第一类丢失更新问题。
  - READ_COMMITED(读已提交)：保证一个事务修改的数据提交后才能被另外一个事务读取，即另外一个事务不能读取该事务未提交的数据(大多数数据库的默认级别，如sql Server，Oracle等)。该级别隔离等级可以解决第一类丢失更新和脏读问题。
  - REPEATABLE_READ(可重复读)：保证一个事务相同条件下前后两次获取的数据是一致的。(mysql常用的)该隔离级别可以解决第一类丢失更新，脏读，不可重复读，第二类丢失更新的问题。
  - SERIALIZABLE(可串行化)：最高的隔离级别，强制事务串行执行。可解决上述所提到的所有问题。

- 持久性（Durability）

  只要事务成功结束，它对数据库所做的更新就必须永久保存下来。即使发生系统崩溃，重新启动数据库系统后，数据库还能恢复到事务成功结束时的状态。

## 小结

总的来说BASE理论面向的是大型高可用、可扩展的分布式系统。与传统ACID特性相反，不同于ACID的强一致性模型，BASE提出通过牺牲强一致性来获得可用性，并允许数据段时间内的不一致，但是最终达到一致状态。同时，在实际分布式场景中，不同业务对数据的一致性要求不同。因此在设计中，ACID和BASE理论往往又会结合使用。
