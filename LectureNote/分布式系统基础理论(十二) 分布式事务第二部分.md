# 分布式系统基础理论(十二)	分布式事务第二部分


   * [分布式系统基础理论(十二)	分布式事务第二部分](#分布式系统基础理论十二分布式事务第二部分)
      * [TCC](#tcc)
         * [基础概念](#基础概念)
         * [基于TCC的电商系统分布式事务解决方案](#基于tcc的电商系统分布式事务解决方案)
            * [TCC实现阶段一：Try](#tcc实现阶段一try)
            * [TCC实现阶段二：Confirm](#tcc实现阶段二confirm)
            * [TCC实现阶段三：Cancel](#tcc实现阶段三cancel)
            * [总结](#总结)
      * [接口同步调用模式与一致性解决方案](#接口同步调用模式与一致性解决方案)
      * [接口异步调用模式与一致性解决方案](#接口异步调用模式与一致性解决方案)
      * [消息异步处理模式与事务一致性解决方案](#消息异步处理模式与事务一致性解决方案)
         * [基于MQ的消息一致性](#基于mq的消息一致性)
            * [普通消息的处理流程](#普通消息的处理流程)
               * [普通消息处理存在的一致性问题](#普通消息处理存在的一致性问题)
            * [事务消息](#事务消息)
            * [支持事务消息的MQ](#支持事务消息的mq)
         * [最大努力通知方案](#最大努力通知方案)
         * [基于本地消息表的最终一致性](#基于本地消息表的最终一致性)
         * [分布式一致性方案中需要注意的点](#分布式一致性方案中需要注意的点)
            * [保证操作幂等性的常用方法](#保证操作幂等性的常用方法)
      * [总结](#总结-1)


分布式事务的种种实现方案基本都借鉴了2PC的思路，但是人们很快发现了新的问题，在分布式系统中，如果仍然采用事务模型来进行数据修改，性能将受到不可避免的影响，一旦其中一个参与者节点出现问题，基本上会导致整个事务发生回滚，这在高并发场景下是无法被接受的。

而根据CAP定理我们很清楚一条原则，要想保证可用性的同时又想完美的保证强一致性是不可能的，于是现在大多数的分布式系统中都对一致性做出了妥协：

我们不追求整个事务操作过程中每个时刻的强一致性，转而追求最终结果的一致性，也就是最终一致性。在整个事务执行流程中，我们是可以接受短暂的数据不一致，只要最后的结果没有问题就ok。

至此，我们对于事务的研究，从满足ACID的刚性事务演变到了BASE的柔性事务。

现阶段常见的分布式解决方案一般有TCC分布式事务、可靠消息一致性事务等柔性事务的分布式事务方案。

## TCC

我们先不介绍具体概念，先通过一个特别常见的业务场景引出TCC事务的必要性。

假设现在有一个电商系统，里面有一个支付订单的场景。

![](https://raw.githubusercontent.com/KyrieJK/Figurebed/master/img/20191219000348.png)

我们成功支付一个订单后，系统需要做一下步骤：

- 更改订单状态为”已支付“
- 扣减商品库存
- 给会员增加积分
- 创建销售出库单通知仓库发货

以这个业务场景为基础，我先来介绍TCC的基本概念，随后我们将利用这个业务场景看看是如何应用TCC的。

### 基础概念

TCC是try-confirm=cancel的单词首字母缩写，是一个类2PC的柔性事务解决方案，由支付宝提出后得到广泛的实践。

下面是在网上直接用的别人的图：

![](https://raw.githubusercontent.com/KyrieJK/Figurebed/master/img/20191219002005.png)

TCC是服务化的两阶段编程模型，其Try、Confirm、Cancel3个方法均由业务编码实现。

其中Try操作作为一阶段，负责资源的检查和预留，Confirm操作作为二阶段提交操作，执行真正的业务，Cancel是预留资源的取消。

业务在实现TCC服务后，该TCC服务将作为分布式事务中的其中一个资源，参与到整个分布式事务中。事务管理器分2阶段协调TCC服务，在第一阶段调用所有TCC服务的Try方法，在第二阶段执行所有TCC服务的Confirm或者Cancel方法。

### 基于TCC的电商系统分布式事务解决方案

上面简单介绍了业务场景以及TCC的基本概念，我们现在需要自主设计一个TCC分布式事务的解决方案。

1. 订单服务：修改订单状态
2. 库存服务：扣减库存
3. 积分服务：增加积分
4. 仓储服务：创建销售出库单

上面的几个步骤，要么一起成功，要么一起失败，必须作为一个整体的事务完成。不允许只完成一部分的情况出现。

比如说，订单的状态已经修改为”已支付“，但是库存服务扣减库存失败。购买商品的库存原本是100，正常情况下，订单中购买了2个，应当只剩98个库存。但是库存服务异常导致扣减库存失败，导致库存还是100个。这种情况在电商系统中是百分之一百不允许出现的。

如果我们不使用基于TCC的分布式事务方案的话，直接用Spring Cloud开发微服务系统，上面的异常情况是很有可能发生的。

![](https://raw.githubusercontent.com/KyrieJK/Figurebed/master/img/20191219003011.png)

这张图很好的诠释了我们说的异常情况。所以我们必须使用TCC分布式事务方案来保证各个服务形成一个整体性的事务。

这4个步骤必须全部成功，如果其中任何一个操作失败了，这四个操作需要全部回滚，撤销已完成的操作。

#### TCC实现阶段一：Try

订单服务子系统，代码大概是：

```java
public class OrderService {

    // 库存服务
    @Autowired
    private InventoryService inventoryService;

    // 积分服务
    @Autowired
    private CreditService creditService;

    // 仓储服务
    @Autowired
    private WmsService wmsService;

    // 对这个订单完成支付
    public void pay(){
        //对本地的的订单数据库修改订单状态为"已支付"
        orderDAO.updateStatus(OrderStatus.PAYED);

        //调用库存服务扣减库存
        inventoryService.reduceStock();

        //调用积分服务增加积分
        creditService.addCredit();

        //调用仓储服务通知发货
        wmsService.saleDelivery();
    }
}
```

pay()方法中完成了4个操作，但是这不足以支撑我们完成TCC分布式事务方案。需要根据TCC方案做一下改造：订单服务先做下单操作，这是个本地事务，能够保证ACID的事务特性。下单成功后，订单服务将当前订单状态由初始化改为处理中进行扣库存操作，这里不能直接将库存扣除，应当冻结库存，将库存减去后，将减去的值保存在已冻结的字段中。

比如：本来库存数量是100，要减去5个库存，不能直接100-5=95。而是要把可销售的库存设置为：100-5=95，接着在一个单独的库存冻结的字段里，设置一个5。也就是说有5个库存是被冻结的。此时订单状态为OrderStatus.UPDATING。

接下来我们需要对代码进行修改。首先，订单服务先把自己的状态修改为：OrderStatus.UPDATING。这样在pay()方法中，订单状态不能直接修改为已支付。我们先把订单状态修改为UPDATING，也就是修改中的意思。为什么不能直接进行支付，然后改为支付完成？因为存在支付失败甚至支付未知的风险，只要进行了支付操作，订单状态就不是初始化了。而UPDATING状态是个没有任何含义的中间状态，代表分布式事务正在进行中。

同理，积分服务的增加积分接口也是一样的，不能直接给用户增加会员积分。可以现在积分表里的一个预增加积分字段加入积分。比如：用户积分原本是1000，现在要增加100积分，可以保持原1000积分不变，再预增加字段prepare_add_credit里，设置一个100，表示有100个积分准备增加。

仓储服务的saleDelivery()接口也是同理，系统可以先创建一个销售出库单，但是这个销售出库单的状态是”UNKNOWN“。刚刚创建的这个发货订单，此时不能确定他的状态是什么。需要等真实发货之后再进行状态的修改。

上面描述的整个过程就是TCC分布式事务中的TRY阶段。如果我们要实现一个TCC分布式事务，首先我们的业务主流程以及各个接口提供的业务含义，不是说直接完成那个业务操作，而是完成一个Try操作。

这个操作，一般都是锁定某个资源，设置一个预备类的状态，冻结部分数据等等，状态均为过渡态，大概都是这类操作。

![](https://raw.githubusercontent.com/KyrieJK/Figurebed/master/img/20191219100554.png)

#### TCC实现阶段二：Confirm

常见的TCC框架，如：ByteTCC、tcc-transaction均为我们实现了事务管理器，用来执行CONFIRM阶段。他们能够对各个子服务的Try阶段执行结果有所感知。

感知各个阶段的执行情况以及推进执行下一个阶段的操作比较复杂，单靠自己手写实现是很难的，我们最好借助开源框架实现。

我们在系统中引入一个TCC分布式事务的框架，订单服务里内嵌的TCC分布式事务框架可以感知到，各个服务的Try操作都成功了。此时TCC分布式事务框架会控制进入TCC下一个阶段，第一个C阶段，CONFIRM阶段。

为了实现这个阶段，我们需要在各个子服务里再加入一些代码。订单服务里，我们可以加入CONFIRM的逻辑，就是正式把订单的状态设置为”已支付“。

```java
public class OrderServiceConfirm {

    public void pay(){
        orderDao.updateStatus(OrderStatus.PAYED);
    }
}
```

库存服务中，我们要加入正式扣除库存的操作，将临时冻结的库存真正的扣除，更新冻结字段为0，并修改库存字段为减去库存后的值。

积分服务将积分变更为增加积分之后的值，修改预增加的值为0，积分值修改为原值+预增加的100积分之和。

仓储服务也是类似，我们将在仓储服务中提供CONFIRM逻辑，将销售出库单的状态正式修改为”已创建“，可以供仓储管理人员查看和使用，而不是停留在之前的中间状态”UNKNOWN“。

各个子服务的Confirm逻辑都实现好之后，一旦订单服务里面的TCC分布式事务框架感知到各个子服务的Try阶段都成功后，就会执行各个子服务的Confirm逻辑。

订单服务内的TCC事务框架会负责与其他子服务内的TCC事务框架进行通信，依次调用各个服务的Confirm逻辑。然后正式完成各个服务的所有业务逻辑的执行。

![](https://raw.githubusercontent.com/KyrieJK/Figurebed/master/img/20191219105916.png)

#### TCC实现阶段三：Cancel

Confirm是针对各个子服务都能正常执行的情况，如果某个子服务发生了异常，这时会进入Cancel阶段。

我们接着从Try阶段的业务情景来说：

1. 订单服务中，当支付失败，Cancel操作需要更改订单状态为支付失败；
2. 库存服务中的Cancel操作要将预扣减的库存加回到原库存，也就是可用库存=98+2=100；
3. 积分服务要将预增加的100个积分扣除；
4. 仓储服务的Cancel操作将发货订单的状态修改为发货取消；

当TCC框架感知到任何一个服务的Try阶段执行失败，就会在和各服务内的TCC分布式事务框架进行通信的过程中，调用各个服务的Cancel逻辑，将事务回滚。

![](https://raw.githubusercontent.com/KyrieJK/Figurebed/master/img/20191219143441.png)

#### 总结

上述我们举的例子基本描述了一个TCC的执行过程，可以看出TCC分布式事务的核心思想。如果我们的系统需要使用TCC分布式事务，首先需要选择某种TCC分布式事务框架，各个服务里就会有这个TCC分布式事务框架在运行。这样我们的代码就从简单的一个接口要改造为3个逻辑，Try-Confirm-Cancel：

- 首先依据服务调用链路依次执行Try逻辑；
- 如果各个子服务Try操作都能成功执行，TCC分布式事务框架推进执行Confirm逻辑，完成整个事务；
- 如果某个服务的Try逻辑有问题，TCC分布式事务框架感知到之后就会推进执行各个服务的Cancel逻辑，撤销之前执行的各种操作。

以上这是三步就是TCC分布式事务的核心思想。当系统出现异常时，比如某个子服务的数据库突然宕机、子服务挂了或者某些需要使用的资源不足，这时TCC的逻辑是先执行Try操作，而不是一次性把业务逻辑做完，进行预操作，看各个子服务能不能基本正常运转，能不能成功预留出需要的资源。

如果Try阶段均能执行成功，也就是说数据库、子服务等都可以正常写入数据，同时需要预留的资源均成功冻结预留(如库存冻结成功、积分添加完成)。

接着再执行各个子服务的Confirm逻辑，基本上Confirm执行完成之后就可以很大概率保证分布式事务的完成。如果Try阶段某个子服务执行失败，比如底层数据库挂了，那么此时就自动执行各个子服务的Cancel逻辑，把之前的Try逻辑都回滚，所有服务都不执行任何设计的业务逻辑。从而保证各个子服务模块一起成功，或者一起失败。

我们还需要考虑一个问题，如果某个子服务突然挂了，然后再次重启，TCC分布式事务框架如何保证之前没有执行完的分布式事务继续执行的？

TCC分布式事务框架都是要记录一些分布式事务的活动日志，可以在磁盘上的日志文件里记录，也可以在数据库里记录。将分布式事务运行各个阶段和状态落到磁盘，做持久化记录。

如果某个子服务的Cancel或者Confirm操作一直失败怎么办？TCC分布式事务框架会通过活动日志记录各个服务的状态。举个例子，比如发现某个服务的Cancel或者Confirm一直没成功，会不停的重试它的Cancel或者Confirm逻辑，直到操作执行成功为止。

## 接口同步调用模式与一致性解决方案

![](https://raw.githubusercontent.com/KyrieJK/Figurebed/master/img/20191220133022.png)

A服务同步调用B服务的接口并等待结果返回，后续的流程会依赖B服务的返回结果，系统会一直阻塞至B服务返回结果。这种接口调用模式下，A服务得到的结果可以分为三种情况：

1. 请求发起阶段网络超时或者异常，B服务未能收到A发过来的请求，未作出相应的处理；
2. 结果返回阶段网络超时或异常，B服务已经收到A过来的请求，并作出相应的处理；
3. 正常结果返回（明确地成功或失败）

**业务场景**：适用于大规模、高并发的短小操作且依赖返回值的场景。例如，交易服务和库存服务（卡券、红包服务）的交互、用户登录和准入服务的交互。

**解决方案**：服务调用方查询重试方案

A服务调用B服务(以扣减库存rpc为例)，有三种情况：网络超时或异常；查询到扣减库存操作；查不到扣减库存操作；

如果调用B服务失败，那么调用方A会重试调用B服务，直到达到我们设置的最大重试次数。

1. 查询重试后依然失败，此时可以启用人工处理或准实时对账系统自动校准；
2. 重试次数不宜设置过多，甚至只重试一次；
3. B服务处理请求要做好幂等性。

## 接口异步调用模式与一致性解决方案

![](https://raw.githubusercontent.com/KyrieJK/Figurebed/master/img/20191220133045.png)

A服务调用B服务，B服务先受理请求并落库，状态是待处理。B服务处理请求耗时较长，或者还要依赖其他的服务。B服务处理完成后通知A服务或者A服务定时去查询B服务的处理结果，而不是A服务一直阻塞在这里等待B服务的返回结果。两种交互模式：

1. 对于CASE-1，第一步和第二步同接口同步调用模式，第3步同消息异步处理模式；
2. 对于CASE-2，相当于两次接口同步调用模式。

**业务场景**：适用于非核心链路上负载较高的处理环节，这个环节耗时较长，并且对时效性要求不高。例如：

- 用户提现时，账户系统和提现系统的交互（CASE-1）；
- 提现系统和三方系统（银行系统或者三方托管系统）的交互（CASE-2）；

**解决方案**：服务被调用方（B服务）最大努力处理方案。由于B服务中请求有落库，所以可以用定时任务不断重试尽最大努力将请求处理出结果。处理后，将请求状态设置成对应的结果落库。然后再通知A服务或者A服务异步主动查询。

B服务通常都是接受请求并持久化后才返回A服务受理成功。避免服务进程被杀掉而导致请求丢失。

无论是CASE-1中的（1，2）两步还是CASE-2中的第（3，4）两步，如果查询重试失败，可以消息直接入库，用定时任务处理，直到处理成功。异步模式与同步模式不同，A服务不需要B服务实时返回结果。

## 消息异步处理模式与事务一致性解决方案

![](https://raw.githubusercontent.com/KyrieJK/Figurebed/master/img/20191220140004.png)

A服务将B服务需要的消息通过消息中间件传递给B服务，A服务无需直到B服务的处理结果。这种交互模式下，消息生产者要确保消息发送成功；消息消费者要确保消息消费成功。

**业务场景**：消息异步处理模式与接口异步调用模式类似，多应用于非核心链路上负载较高的处理环节，并且服务的上游不关心下游的处理结果，下游也不需要向上游返回处理结果。在电商系统中，用户下订单支付且交易成功后，发送消息给物流系统或者账务系统进行后续的处理。

**解决方案**：事务消息-基于MQ的消息一致性；非事务消息-基于本地消息的最终一致性

### 基于MQ的消息一致性

#### 普通消息的处理流程

![](https://raw.githubusercontent.com/KyrieJK/Figurebed/master/img/20191219154409.png)

1. 消息生产者发送消息
2. MQ收到消息，将消息持久化落盘，在存储中新增一条记录
3. 返回ACK给生产者
4. MQ push消息给对应的消费者，然后等待消费者返回ACK
5. 如果消费者在指定时间内成功返回ACK，那么MQ认为消息消费成功，在存储中删除消息。如果MQ在指定时间内没有收到ACK，则认为消息消费失败，会尝试重新push消息，重复执行4、5两步的操作。

##### 普通消息处理存在的一致性问题

我们以订单创建为例，订单系统先创建订单（本地事务），再发送消息给下游处理；如果订单创建成功，然而消息没有发送出去，那么下游所有系统都无法感知到这个事件，会出现脏数据；

```java
public void processOrder() {
    // 订单处理(业务操作) 
    orderService.process();
    // 发送订单处理成功消息(发送消息) 
    sendBizMsg ();
}
```

如果先发送订单消息，再创建订单；那么就有可能消息发送成功，但是在订单创建的时候却失败了，此时下游系统却认为这个订单已经创建，也会出现脏数据。

```java
public void processOrder() {
   // 发送订单处理成功消息(发送消息) 
    sendBizMsg ();
    // 订单处理(业务操作) 
    orderService.process();
}
```

换个思路，如果我们把消息发送和业务处理放在同一个本地事务中来进行处理，如果业务消息发送失败，那么本地事务就回滚，这样是否可以成功解决消息发送的一致性问题呢。

```java
@Transactionnal
public void processOrder() {
    try{
        // 订单处理(业务操作) 
        orderService.process(); 
        // 发送订单处理成功消息(发送消息) 
        sendBizMsg ();
    }catch(Exception e){
         事务回滚;   
    }
}
```

我们分析这种方案在实际生产过程中可能会发生的几种异常：

- 订单处理成功，此时突然宕机，事务还未提交，消息也没有发送出去，事务回滚；
- 订单处理成功，由于网络原因或MQ宕机，消息没有发送出去，事务回滚；
- 订单处理成功，消息发送成功，但是MQ由于其他原因，导致消息存储失败，事务回滚；
- 订单处理成功，消息发送成功，MQ存储消息成功，但是MQ处理超时了，导致ACK确认失败，导致发送方本地事务回滚；

上面描述的4中异常情况，前3个异常情况，这种方案可以有效地确保系统事务一致性，但是第4种情况会造成事务不一致。使用普通的处理方式，无论如何，都无法保证业务处理与消息发送两边的一致性，其根本原因在于：远程调用，结果最终可能为成功、失败、超时；对于超时的情况，处理方最终的结果可能是成功，也可能是失败，调用方无法获知。比如，调用方现在本地写数据，然后发起RPC服务调用，但是处理方由于DB数据量比较大，导致处理超时，调用方在出现超时异常后，直接回滚本地事务，从而导致调用方没有数据，而处理方那边数据却已经写入了，最终导致两边业务数据不一致。

#### 事务消息

由于普通消息方式无法解决消息生产者本地事务处理成功与消息发送成功两者的一致性问题。因此事务消息就诞生了，它实现了消息生产者本地事务与消息发送的原子性，保证了消息生产者本地事务处理成功与消息发送成功的最终一致性问题。

事务消息处理的流程如下所示：

![](https://raw.githubusercontent.com/KyrieJK/Figurebed/master/img/20191219165801.png)

1. 事务消息与普通消息的区别就在于消息生产环节，生产者预先发送一条消息到MQ，也可以叫做half消息；
2. MQ接收到消息后，先进行持久化，则存储中会新增一条状态为”待发送“的消息；
3. MQ返回ACK给消息生产者，此时MQ不会触发消息推送事件；
4. 生产者预发送消息成功后，执行本地事务；
5. 执行本地事务，执行完成后，发送执行结果给MQ；
6. MQ会根据执行结果删除或者更新消息状态为”可发送“；
7. 如果消息状态更新为”可发送“，则MQ会push消息给消费者，后面消息的消费和普通消息是相同的流程；

事务消息的方案可以使得我们从容应对系统中各式各样的异常情况发生：

| 异常情况                                                     | 一致性 | 处理异常方法                                                 |
| ------------------------------------------------------------ | ------ | ------------------------------------------------------------ |
| 消息未存储，业务操作未执行                                   | 一致   | 无                                                           |
| 存储”待发送“消息成功，但是ACK失败，导致业务未执行(可能是MQ处理超时、网络抖动等原因) | 不一致 | MQ确认业务操作结果，根据具体情况处理消息                     |
| 存储”待发送“消息成功，ACK成功，业务执行(成功或者失败)，但是MQ没有收到生产者业务处理的最终结果 | 不一致 | MQ确认业务操作结果，处理消息(根据业务处理结果，更新消息状态，如果业务执行成功，则向消费端push消息，失败则删除消息) |
| 业务处理成功，并发送结果给MQ，但是MQ更新消息失败，导致消息状态依旧为”待发送“ | 不一致 | 同上                                                         |

#### 支持事务消息的MQ

目前较为主流的MQ，比如RabbitMQ、Kafka、RocketMQ等，只有RocketMQ支持事务消息。早年阿里对MQ增加事务消息也是因为支付宝因为业务上有需要才产生的。因此，如果我们希望强依赖一个MQ的事务消息来做到消息最终一致性的话，在目前情况下，我们只能选择RocketMQ来解决。上面表格中列举的几种异常情况，MQ存储了”待发送“的消息，但是MQ无法感知到上游处理的最终结果。对于RocketMQ而言，它的解决方案是内部实现一个定时任务，去轮询状态为”待发送“的消息，然后给消息生产者发送check请求，而生产者内部必须实现一个check接口，这个接口就是用来检查与之对应的本地事务是否成功，如果成功了，则MQ会将消息设置为”可发送“，否则就删除消息。

我们需要明确几个常见的问题：

- 如果预发送消息失败，是不是业务就不执行了？

  确实不执行了。对于基于消息的最终一致性方案，一般都会强依赖这步，如果这个步骤无法得到保证，那么最终也不可能做到最终一致性。

- 如果消费端消费失败，是否需要消息生产者做回滚？

  生产者不会因为消费者消费失败而回滚，采用事务消息的应用，其所追求的是高可用和最终一致性，消费消息失败的话，MQ自己会负责重推消息，直到消费成功。因此事务消息是针对生产者说的，而消费端的一致性是通过MQ的重试机制来完成的。

- 如果consumer因为业务异常而导致回滚，那么生产者和消费者的事务一致性无法保证

  基于消息的最终一致性方案必须保证消费端在业务上的操作没有障碍，只允许系统异常的失败，不允许业务上的失败。

- 如果消费端接收到消息后，本地执行事务失败了没有返回ACK应该怎么办？这时系统会基于MQ重试，MQ会自动不断重试直到消费成功，如果实在不行，可以发送告警由人工来手工回滚和补偿。这种方案的要点就是可以基于MQ来进行不断重试，最终一定会执行成功的。因为一般执行失败的原因是网络抖动或者数据库瞬间负载太高，都属于暂时性问题。通过这种方案，99.9%的情况都是可以保证数据最终一致性的，剩下0.1%出问题的时候，就需要人工修复数据。

### 最大努力通知方案

![](https://raw.githubusercontent.com/KyrieJK/Figurebed/master/img/20191220003827.png)

1. 系统A本地事务执行完之后，发送个消息到MQ。
2. 系统会专门设置一个专门消费MQ的最大努力通知服务，这个服务会消费MQ，然后写入数据库中记录下来或者放入内存队列。接着调用系统B的接口。
3. 如果系统B执行本地事务失败了，那么此时最大努力通知服务就定时尝试重新调用系统B，反复N次，最后还是不行就放弃。系统B也可以主动查询系统A的相关业务查询接口。

这套方案和上面提到的可靠消息最终一致性方案相比，可靠消息最终一致性方案可以保证只要生产者的本地事务完成，通过无限次重试来保证消费端的事务总会完成。但是最大努力通知方案不同，如果消费者本地事务执行失败，那么它会重试N次后就不再重试，消费端的本地事务可能就不会完成了。至于说重试次数，这个需要根据具体的业务场景来确定。

### 基于本地消息表的最终一致性

![](https://raw.githubusercontent.com/KyrieJK/Figurebed/master/img/20191220005316.png)

基于RocketMQ的最终一致性方案是对于事务消息来说的，如果我们采用非事务消息来完成分布式事务一致性方案，我们采用基于本地消息的最终一致性方案。

基于本地消息的最终一致性方案的核心点就是在执行业务操作的时候，记录一条消息数据到本地数据库，并且消息数据的记录与业务数据的记录必须在同一事务内完成，这是本方案的前提核心保障。在记录消息数据入库后，状态为”待发送“，后面我们就可以通过一个定时任务到DB中去轮询状态为”待发送“的消息，然后将消息投递给MQ。这个过程中可能存在消息投递失败的可能，此时就依靠”重试机制“来保证，直到成功收到MQ的ACK确认之后，再讲消息状态更新或者消息消除；而后面消息端消费消息失败的话，则依赖MQ本身的重试机制来完成，这就要求消息消费者做好幂等，最后做到两边系统数据的最终一致性。但是这个方案也有一个弊端，每个业务系统在使用该方案时，都需要在对应的业务库创建一张消息表来存储消息。

### 分布式一致性方案中需要注意的点

#### 保证操作幂等性的常用方法

- 有业务状态：业务逻辑来保证幂等。例如接到支付成功的消息订单状态变成支付完成，如果当前状态是支付完成，则再收到一个支付成功或者支付成功之前状态的消息则说明消息重复了，不用再次处理。
- 无业务状态：业务唯一ID保证幂等。增加一个去重表（或者分布式缓存）来记录有业务唯一ID的操作。比如调用充值接口，当请求过来时，会根据唯一充值ID去查充值流水表，若已经存在，则直接返回；否则继续进行充值操作。

## 总结

- 接口同步调用模式，服务调用方查询重试方案和TCC分布式事务方案；
- 接口异步调用模式，服务被调方最大努力处理方案；
- 消息异步处理模式，生产者最大努力通知+消费者最大努力处理方案；
- 任何服务操作都需要提供一个查询接口，用来向外部输出操作执行的状态；