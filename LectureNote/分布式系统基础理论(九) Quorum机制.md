# 分布式系统基础理论(九)	Quorum机制


   * [分布式系统基础理论(九)	Quorum机制](#分布式系统基础理论九quorum机制)
      * [Write-all-read-one](#write-all-read-one)
      * [Quorum定义](#quorum定义)
         * [读取最新成功提交的数据](#读取最新成功提交的数据)
         * [基于Quorum机制选择primary](#基于quorum机制选择primary)


Quorum机制是一种简单有效的副本管理机制。我们先讨论一下WARO(write-all-read-one)机制，在此基础上，放松约束，讨论Quorum机制。

为了方便下面讨论，我们约定写入操作是一系列顺序的过程，通过其他机制确定写入操作的顺序（primary-secondary架构中由primary决定顺序），每个写入操作记为wi，i为写入操作单调递增的序号，每个wi执行成功后副本数据都发生变化，称为不同的数据版本，记作vi。假设每个副本都保存了历史上所有版本的数据。

## Write-all-read-one

Write-all-read-one是一种简单粗暴的副本控制规则，即在发生写入操作时写所有的副本，只有在所有的副本上写入成功，才认为写入操作成功，从而保证所有的副本一致，这样在读取数据时可以读取任一副本上的数据。

假设有一种magic的机制，当某次写入操作w<sub>i</sub>一旦在所有N个副本上都执行成功，此时全局都能知道这个信息，此后读取操作将指定读取数据版本为vi的数据，称在所有N个副本上都成功的写入操作为”成功提交的写入操作“，称对应的数据为”成功提交的数据“。在WARO机制中，如果某次写入操作w<sub>i</sub>在某个副本上失败了，此时该副本的最新的数据只有v<sub>i-1</sub>。由于不满足在所有N个副本上都成功，则w<sub>i</sub>不是一个成功提交的写入操作，此时，虽然其他N-1个副本上最新的数据是v<sub>i</sub>，但v<sub>i</sub>不是一个成功提交的数据，最新的成功提交的数据只是v<sub>i-1</sub>。

这种magic机制还是需要依赖于元数据服务器。我们把版本号信息存放到元数据服务器上。假如写入操作非常频繁，那么记录写入成功的版本号v<sub>i</sub>将成为一个关键操作，容易成为系统瓶颈。为了实现强一致性，在读取数据前必须先读取元数据中的版本号，在大压力下也容易因为元数据服务器的性能造成系统瓶颈。

由于写入操作需要在所有的N个副本上都成功，写入操作才能成功，所以一旦有一个副本异常，写入操作失败，写入操作就不会生效。对于写入服务，虽然有N个副本，但是系统无法容忍任何一个副本异常。另一方面，N个副本中只要有一个副本正常，系统就可以提供读服务。对于读服务而言，当有N个副本时，系统可以容忍N-1个副本异常。

从上述分析可以得出结论，WARO读服务的可用性很高，但是写服务的可用性不高，甚至虽然使用了副本，但是写服务的可用性等效于没有副本。

## Quorum定义

WARO牺牲了写入服务的可用性，最大程度的增强读服务的可用性。现在将WARO的条件进行松弛，从而使得可以在读写服务可用性之间做折中，得出Quorum机制。

在Quorum机制下，当某次写入操作w<sub>i</sub>一旦在所有N个副本中的W个副本上都成功，则就称该写入操作为”成功提交的写入操作“，称对应的数据为”成功提交的数据“。令R>N-W，由于写入操作w<sub>i</sub>仅在W个副本上成功，所以在读取数据时，最多需要读取R个副本则一定能读到w<sub>i</sub>写入后的数据v<sub>i</sub>。如果某次写入操作w<sub>i</sub>在W个副本上成功，由于W+R>N,任意R个副本组成的集合一定与成功的W个副本组成的集合有交集，所以读取R个副本一定能读到w<sub>i</sub>写入后的数据v<sub>i</sub>。Quorum机制的原理如下图所示。

![](https://raw.githubusercontent.com/KyrieJK/Figurebed/master/img/20191209093659.png)

举个例子，某系统由5个副本，W=3，R=3，最初5个副本的数据一致，都是v<sub>1</sub>，某次写入操作w<sub>2</sub>在前3个副本上成功，副本情况变成（v<sub>2</sub>v<sub>2</sub>v<sub>2</sub>v<sub>1</sub>v<sub>1</sub>）。此时，任意3个副本组成的集合中一定包括v<sub>2</sub>。

在上述定义中，令W=N，R=1，就得到WARO，可以看到WARO实际上是Quorum机制的一种特殊情况。

分析Quorum机制的可用性。限制Quorum参数为W+R=N+1.由于写入操作需要在W个副本上都成功，写入操作才能成功，所以一旦N-W+1个副本异常，写入操作始终无法在W个副本上成功，写服务不可用。另一方面，一旦N-R+1个副本异常，则无法保证一定可以读到与W个副本有交集的副本集合，则读服务的一致性下降。

若N=5，W=2，R=3时，若4个副本异常，写入操作始终无法完成。若3个副本异常时，剩下的两个副本虽然可以提供写入服务，但是对于读取而言，在读取者不知道当前最新已成功提交的版本是什么的时候，仅仅读取2个副本并不能保证一定可以读到最新的已提交的数据。

仅仅依赖Quorum机制是无法保证强一致性的。因为仅有Quorum机制时无法确定最新已成功提交的版本号，除非将最新已提交的版本号作为元数据由特定的元数据服务器或元数据集群管理，否则很难确定最新成功提交的版本号。后面我们会讨论在哪些情况下，可以仅通过Quorum机制来确定最新成功提交的版本。

Quorum机制的三个系统参数N、W、R控制了系统的可用性，也是系统对用户的服务承诺：数据最多有N个副本，但数据更新成功W个副本即返回用户成功。对于一致性要求较高的Quorum系统，系统还应该承诺任何时候不读取未成功提交的数据，即读取到的数据都是曾经在W个副本上成功的数据。

### 读取最新成功提交的数据

现在我们讨论读取者在不知道当前已提交的数据版本号，在Quorum机制下如何始终读取成功提交的数据，以及如何确定最新的已经提交的数据。

Quorum机制只需成功更新N个副本中的W个，在读取R个副本时，一定可以读取到最新的成功提交的数据。但由于有不成功的更新情况存在，仅仅读取R个副本却不一定能确定哪个版本的数据是最新已提交的数据。对于一个强一致性Quorum系统。

在N=5，W=3，R=3的系统中，某时刻副本最大版本号为(v<sub>2</sub>v<sub>2</sub>v<sub>2</sub>v<sub>1</sub>v<sub>1</sub>)。注意，这里继续假设有v<sub>2</sub>的副本也有v<sub>1</sub>，上述列出的只是最大版本号。此时，最新的成功提交的副本应该是v<sub>2</sub>，因为从全局看v<sub>2</sub>已经成功更新了3个副本。读取任何3个副本，一定能读到v<sub>2</sub>。但仅读3个副本时，有可能读到(v<sub>2</sub>v<sub>1</sub>v<sub>1</sub>)，如图2-11(a)。此时，由于v<sub>2</sub>蕴含v<sub>1</sub>，可知v<sub>1</sub>是一个成功提交的版本，但是却不能判定v<sub>2</sub>一定是一个成功提交的版本。这是因为图2-11(b)，假设副本最大版本号为(v<sub>2</sub>v<sub>1</sub>v<sub>1</sub>v<sub>1</sub>v<sub>1</sub>)，当读取3个副本时也可能读到(v<sub>2</sub>v<sub>1</sub>v<sub>1</sub>)，此时v<sub>2</sub>是一个未成功提交的版本。所以在本例中，仅读到(v<sub>2</sub>v<sub>1</sub>v<sub>1</sub>)时，可以肯定的是最新的成功提交的数据要么是v<sub>1</sub>要么是v<sub>2</sub>,却没办法确定究竟是哪一个。

![](https://raw.githubusercontent.com/KyrieJK/Figurebed/master/img/20191209110901.png)

对于一个强一致性系统，应该始终读取返回最新的成功提交的数据，在Quorum机制下，要达到这一目的需要对读取条件做进一步加强。

1. 限制提交的写入操作必须严格递增，即只有在前一个写入操作成功提交后才可以提交后一个写入操作，从而成功提交的数据版本号必须是连续增加的。

2. 读取R个副本，对于R个副本中版本号最高的数据(如v<sub>2</sub>)，判断

   if：已存在W个，则该数据为最新的成功提交的数据

   if：若存在数据版本为v<sub>2</sub>的副本个数少于W个，假设为X个，则继续读取其他副本，直若成功读取到W个该版本的副本，则该数据为最新的成功提交的数据；如果在所有副本中该数据的个数肯定不满足W个，则R中版本号第二大的为最新的成功提交的副本。

接着上面的例子继续说，在读取到(v<sub>2</sub>v<sub>1</sub>v<sub>1</sub>)时，继续读取剩余的副本，若读到剩余两个副本为(v<sub>2</sub>v<sub>2</sub>)，则v<sub>2</sub>是最新的已提交的副本；若读取剩余的两个副本为(v<sub>2</sub>v<sub>1</sub>)或(v<sub>1</sub>v<sub>1</sub>)，则v<sub>1</sub>是最新成功提交的版本；若读取后续两个副本有任一超时或失败，则无法判断哪个版本是最新的成功提交的版本。

可以得出，在单纯使用Quorum机制时，若要确定最新的成功提交的数据版本，最多需要读取R+（W-R-1）=N个副本，当出现任一副本异常时，读最新的成功提交的版本这一功能都有可能不可用。实际工程中，应当尽量通过其他技术手段，回避通过Quorum机制读取最新的成功提交的版本。当Quorum机制与primary-secondary控制协议结合使用时，可以通过读取primary的方式读取到最新的已提交的数据。

### 基于Quorum机制选择primary

本节介绍一种介于Quorum机制选择primary的技术。在primary-secondary协议中，primary负责进行更新操作的同步工作。现在基本primary-secondary协议中引入Quorum机制，即primary成功更新W个副本（包括primary自身）后向用户返回成功。读取数据时依照一致性要求的不同可以有不同的做法：如果需要强一致性的立刻读取到最新的成功提交的数据，则可以简单的只读取primary副本上的数据即可，也可以通过上节提到的方式读取；如果需要会话一致性，则可以根据之前已经读到的数据版本号在各个副本上进行选择性读取；如果只需要弱一致性，则可以选择任意副本读取。

在primary-secondary协议中，当primary异常时，需要选择出一个新的primary，之后secondary副本与primary副本同步数据。**通常情况下，选择新的primary的工作是由某一个中心节点完成的，在引入Quorum机制后，常用的primary选择方式与读取数据的方式类似，即中心节点读取R个副本，选择R个副本中版本号最高的副本作为新的primary。**新primary与至少W个副本完成数据同步后作为新的primary继续提供读写服务。首先，R个副本中版本号最高的副本一定蕴含了最新的成功提交的数据。虽然不能确定最高版本号的数据是一个成功提交的数据，但新的primary在随后与secondary同步数据，使得该版本的副本个数达到W个，从而使得该版本的数据成为成功提交的数据。

比如：在N=5，W=3，R=3的系统中，某时刻副本最大版本号（v<sub>2</sub>v<sub>2</sub>v<sub>1</sub>v<sub>1</sub>v<sub>1</sub>），此时v<sub>1</sub>是系统的最新的成功提交的数据，v<sub>2</sub>是一个处于中间状态的未成功提交的数据。假设此刻原primary副本异常，中心节点进行primary切换工作。这类中间态数据究竟作为“脏数据”被删除还是作为新的数据被同步后成为生效的数据，完全取决于这个数据能否参与新primary的选举。如下图所示：

![](https://raw.githubusercontent.com/KyrieJK/Figurebed/master/img/20191209142421.png)

1. 如果中心节点与其中3个副本通信成功，读取到的版本号为(v<sub>1</sub>v<sub>1</sub>v<sub>1</sub>),则任选一个副本作为primary，新primary以v<sub>1</sub>作为最新的成功提交的版本并与其他副本同步，当与第1、2个副本同步数据时，由于第1、第2副本版本号大于primary，属于脏数据。实践中，新primary也有可能与后两个副本完成同步后就提供数据服务，随后自身版本号也更新到v<sub>2</sub>,如果系统不能保证之后的v<sub>2</sub>与之前的v<sub>2</sub>完全一样，则新primary在与第1、2个副本同步数据时不但要比较数据版本号还需要比较写入操作的具体内容是否相同。
2. 第二点如下图所示，若中心节点与其他3个副本通信成功，读取到的版本号为（v<sub>2</sub>v<sub>1</sub>v<sub>1</sub>），则选取版本号为v<sub>2</sub>的副本作为新的primary，随后，一旦新primary与其他2个副本完成数据同步，则符合v<sub>2</sub>的副本个数达到W个，成为最新的成功提交的副本，新primary可以提供正常的读写服务。

![](https://raw.githubusercontent.com/KyrieJK/Figurebed/master/img/20191209143003.png)

