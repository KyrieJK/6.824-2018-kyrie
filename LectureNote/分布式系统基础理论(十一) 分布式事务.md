# 分布式系统基础理论(十一)	分布式事务第一部分


   * [分布式系统基础理论(十一)	分布式事务第一部分](#分布式系统基础理论十一分布式事务第一部分)
      * [什么是事务](#什么是事务)
      * [分布式事务](#分布式事务)
         * [什么是分布式事务](#什么是分布式事务)
         * [为什么会出现分布式事务](#为什么会出现分布式事务)
      * [刚性事务OR柔性事务](#刚性事务or柔性事务)
      * [数据一致性问题](#数据一致性问题)
         * [数据一致性的情形](#数据一致性的情形)
      * [两阶段提交](#两阶段提交)
         * [XA规范](#xa规范)
         * [2PC协议](#2pc协议)
            * [请求/表决阶段](#请求表决阶段)
            * [提交/执行阶段](#提交执行阶段)
         * [两阶段提交存在的问题](#两阶段提交存在的问题)
      * [三阶段提交](#三阶段提交)
         * [第一阶段：CanCommit阶段](#第一阶段cancommit阶段)
         * [第二阶段：PreCommit阶段](#第二阶段precommit阶段)
         * [第三阶段：DoCommit阶段](#第三阶段docommit阶段)
            * [执行提交](#执行提交)
            * [中断事务](#中断事务)

一开始本来想在一篇文章中记录一下对分布式事务的理解，但是因为分布式事务需要理解的内容实在太多了，所以这里分成两篇文章来做个笔记吧。

## 什么是事务

提到事务，我们一般的认知是数据库中的Transaction，事务的四大特性想必大家也非常熟悉：ACID，原子性，一致性，隔离性，持久性。在这篇文章中我不会深入去说ACID四大特性的具体内容，这里简单介绍一下事务即可，毕竟这篇文章主要是深入讲解分布式事务。

简单来说事务是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单元。举个最经典的例子来说：银行转账，我们要从A账户转1000元到B账户。正常情况下如果从A转出1000到B账户之后，A账户余额减1000，B账户余额增加1000，我们分别用A1和B1操作来表示。

我们当前需要明确一点，在系统中，从A账户减1000和B账户余额增加1000，这是两个操作。既然是两个操作就一定存在先后执行顺序，所以就有可能出现A1操作完毕后正准备去执行B1操作，这时数据库宕机了。如果我们不对这种异常情况加以考虑，那么就会出现，A账户的钱减少了1000，B账户的余额却没有增加，钱不翼而飞了。这种问题在银行业务中是绝对禁止出现的，因为为了解决“钱”的问题，引入了“事务”的概念。银行为了防止这种小概率事件发生，如果A和B无法同时成功，那么在出现问题的时候，事务保证这两个操作会同时失败。因此事务通过ACID特性，保证一系列的操作在任何情况下都可以安全正确地执行。

## 分布式事务

### 什么是分布式事务

分布式事务是指会涉及到操作多个数据库的事务。其实就是将单机上对同一个数据库事务的概念扩大到了多个库的事务。事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。一次大操作由不同的小操作组成，这些小的操作分布在不同的服务器上，且属于不同的应用，分布式事务需要保证这些小操作要么全部成功，要么全部失败。目的是为了保证分布式系统中的不同数据库的数据一致性。

### 为什么会出现分布式事务

分布式事务和普通事务之间到底有什么区别？为什么会出现分布式事务呢，接下来就找一个简单的例子来说明一下分布式事务出现的必要性。

![](https://raw.githubusercontent.com/KyrieJK/Figurebed/master/img/20191216101955.png)

如上图所示，这是一个单块的大系统。各个功能模块都在一个单机的系统内。现在有一个操作需要按顺序去调用完成这3个模块中的接口。这个操作是一个整体，包含在一个事务中，要么同时成功，要么同时失败回滚。但是这种简单架构的系统仅限于小流量系统使用，一旦流量增大超过单机系统的资源限制，会造成系统的可用性大大降低。所以后面才会出现把单块系统拆分成分布式系统或微服务架构，这时事务的概念以及使用方法就和单机事务有所不同了。

我们可以看到下图所示，拆分成分布式系统之后的架构图：

![](https://raw.githubusercontent.com/KyrieJK/Figurebed/master/img/20191216102436.png)

上图是同一个操作在分布式系统中的执行情况。员工模块、财务模块和请假模块从原来的单块的大系统中拆分出来，各自形成自己的系统：员工系统、财务系统、请假系统。这张图里的数据库表述还不够准确，三个系统可以各自使用自己的数据库，而不是使用同一个数据库。

一个用户进行一个操作，这个操作需要先调用员工系统预先处理，然后通过http或者rpc的方式分别调用财务系统和请假系统的接口做进一步的处理，它们的操作都需要分别落地到各自数据库中。这3个系统的一系列操作其实是需要全部被包裹在同一个分布式事务中的，此时这3个系统的操作，要么同时成功要么同时失败。

三个子系统：员工系统、财务系统、请假系统之间就通过http或rpc进行通信，而不再是一个单块系统中不同模块之间的调用，这就是分布式系统和单块系统最大的区别。

我还找到了一张图可以更好的解释分布式系统架构，各位可以看看：

![](https://raw.githubusercontent.com/KyrieJK/Figurebed/master/img/20191216104029.png)

三个子系统分布在不同节点上，使用各自的Dao模块。

总结一下：分布式服务，就是把之前通过本地接口交互的模块，拆分成单独的应用独立部署，并通过远程接口和网络消息交互。而集中式架构，要想保证订单表和库存表的一致性，只要一个本地事务(ACID)就能保证两者的强一致性。分布式架构，订单表由订单服务操作，库存表由库存服务操作。要想保证订单表和库存表一致性，就必须保证订单服务对订单表的操作和库存服务对库存表的操作同时成功。本地事务演进成了一个分布式事务。由于服务之间通过网络交互，而网络异常属于常态，属于我们必须要考虑的范围之内，这会产生服务间数据不一致的情况。这就涉及一个分布式事务一致性的问题，后面详细讲。



## 刚性事务OR柔性事务

在单数据库事务完全遵循ACID规范，属于刚性事务，而分布式事务要完全遵循ACID规范比较困难，分布式事务属于柔性事务，满足BASE理论。CAP定理告诉我们，对于一个分布式系统（由于网络分区的存在），它无法同时保证一致性、可用性和分区容忍性，而是必须要舍弃其中的一个。对于分布式系统，分区容忍性是不能够舍弃的，所以我们一般根据业务场景，在一致性和可用性中二选一。

柔性事务是对分布式事务说的，说白了就是利用可以利用的业务弹性，使得事务达到最终一致，分布式事务天然不能一蹴而就，柔性事务是一种思想，利用业务上对于事务过程中不一致的容忍度，找到让事务最终一致的方法，寻求一种技术能力和业务诉求平衡的方法。比如转账，A账号的钱减少、B账号的钱增加，刚性事务是要求这两个增加和减少是同时发生的，柔性事务的思想则是先减少A的钱，然后再增加B的钱，分布式环境下，难以保证同时增加和减少，但是只要保证A的钱减少之后，在B能接受的时间范围内，最终给B加上去，也就是最终一致，这就是柔性事务的思想。

分布式事务属于柔性事务，符合BASE理论，我们前面的文章也专门有一篇讲到过BASE理论：Basic Availability、Soft state、Eventual consistency。

柔性事务对ACID的支持：

1. 原子性：严格遵循；
2. 一致性：事务完成后的一致性严格遵循，事务中的一致性可适当放宽，达到最终一致性；
3. 隔离性：并行事务间不可影响；事务中间结果可见性允许安全放宽；
4. 持久性：严格遵循；

为了可用性、性能的需要，柔性事务降低了一致性与隔离性的要求，即”基本可用，最终一致“。

## 数据一致性问题

分布式系统必然会带来数据一致性问题，问题源头就在于数据冗余和分布并通过网络交互+网络异常是常态。

### 数据一致性的情形

- **主库、从库和缓存数据一致性**，相同数据冗余，关系型数据库，为保证数据库的高可用和高性能，一般会采用主从架构并引入缓存。其中数据不一致性存在于数据冗余的时间窗口内。
- **多副本数据之间的数据一致性**，相同数据副本，大数据领域，一份数据会有多副本并存储到不同节点上。客户端可以访问任何一个节点进行读写操作。常用的解决方案是基于Paxos、ZAB、Raft、Quorum、Gossip等一致性协议。
- **分布式服务之间的数据一致性**，相关数据分布，分布式服务，不同的服务操作不同的库，而且库间需要保持一致性。常用的解决方案是分布式事务一致性解决方案。也是本文接下来要讨论的内容。

## 两阶段提交

在分布式系统中，各个节点之间在物理上相互独立，通过网络进行沟通和协调。由于存在事务机制，可以保证每个独立节点上的数据操作可以满足ACID。但是，相互独立的节点之间无法准确的知道其他节点中的事务执行情况。所以从理论上讲，两台机器理论上无法达到一致的状态。如果想让分布式部署的多台机器中的数据保持一致性，就要保证在所有节点的数据写操作，要么全部都执行，要么全部都不执行。

其实这部分内容在文章开头以及提及过一遍，但是现在是为了引入”协调者“组件的概念。一台机器在执行本地事务的时候无法知道其他机器中的本地事务的执行结果。所以它就不知道本次事务到底应该commit还是rollback。所以常规的解决办法就是引入一个”协调者“的组件来统一调度所有分布式节点的执行。

### XA规范

X/Open组织定义了分布式事务处理模型。X/Open DTP模型包括应用程序（AP）、事务管理器（TM）、资源管理器（RM）、通信资源管理器（CRM）四部分。一般，常见的事务管理器TM是交易中间件，常见的资源管理器RM是数据库，常见的通信资源管理器CRM是消息中间件。通常把一个数据库内部的事务处理，如对多个表的操作，作为本地事务看待。数据库的事务处理对象是本地事务，而分布式事务处理的对象是全局事务。所谓全局事务，是指分布式事务处理环境中，多个数据库需要共同完成一个工作，这个工作即是一个全局事务。比如一个事务中更新几个不同的数据库。对数据库的操作发生在系统的各个模块但是必须全部被提交或回滚。此时一个数据库对自己内部所做操作的提交不仅依赖本身操作是否成功，还要依赖于全局事务相关的其他数据库的操作是否成功，如果任何一个数据库的操作失败，则参与此事务的所有数据库所做的所有操作必须回滚。

一般情况下，某一个数据库无法知道其他数据库的动作，因此在一个DTP环境中，交易中间件是必需的，由它通知和协调相关数据库的提交或回滚。而一个数据库只将其自己所做的操作映射到全局事务中。

> XA就是X/Open DTP定义的交易中间件与数据库之间的接口规范（接口函数），交易中间件用它来通知数据库事务的开始、结束以及提交、回滚等。XA接口函数由数据库厂商提供。
>
> 两阶段提交和三阶段提交就是根据这一思想衍生而来的。可以说两阶段提交其实就是实现XA分布式事务的关键。下面我们就来详细讲解一下两阶段提交的详细过程。
>
> ### 2PC协议
>
> 二阶段提交是指，在计算机网络以及数据库领域内，为了使基于分布式系统架构下的所有节点在进行事务提交时保持一致性而设计的一种算法。通常，二阶段提交也被称为是一种协议。在分布式系统中，每个节点虽然可以知晓自己的操作成功或者失败，却无法知道其他节点的操作是否成功。当一个事务跨越多个节点时，为了保持事务的ACID特性，需要引入一个作为协调者的组件来统一掌控所有节点（也可以称为参与者）的操作结果并最终指示这些节点是否要把操作结果进行真正的提交（将更新后的数据写入磁盘）。因此，二阶段提交的算法思路可以概括为：参与者将操作结果通知协调者，再有协调者根据所有参与者的反馈情报决定各参与者是否要提交操作还是中止操作。
>
> 两阶段是指：
>
> - 第一阶段：准备阶段（请求/表决阶段）
> - 第二阶段：提交阶段（执行阶段）
>
> #### 请求/表决阶段
>
> ![](https://raw.githubusercontent.com/KyrieJK/Figurebed/master/img/20191217152344.png)
>
> 分布式事务发起者向协调者发起请求调用，事务协调者分别给每个参与者发送事务预处理请求，称为Prepare消息，有些资料也叫”Vote Request“。我们将这一阶段的步骤细化：
>
> 1. 协调者节点向所有参与者节点询问是否可以执行提交操作（vote），并开始等待各参与者节点的响应。
> 2. 参与者节点收到Prepare消息后，一般来说就会打开本地数据库事务，然后开始执行数据库本地事务，并将Undo信息和Redo信息写入日志，但在执行完成后并不会立刻提交数据库本地事务。
> 3. 各参与者节点响应协调者节点发起的询问。如果参与者节点的事务操作实际执行成功，则各个参与者节点均会返回一个”同意“消息；如果参与者节点的事务操作实际执行失败，则返回一个”中止“消息。
>
> #### 提交/执行阶段
>
> 如果协调者收到了参与者的失败消息或者超时未收到反馈消息，直接给每个参与者发送回滚Rollback消息；反之，如果所有参与者节点都向协调者报告说”我这边可以成功处理此次事务“，那么协调者就会向所有参与者节点发送”全局提交确认通知（global commit）“，通知参与者节点说你们都可以进行本地事务提交了；参与者根据协调者的指令执行提交或者回滚操作，释放所有事务处理过程中使用的锁资源。（必须在最后阶段释放锁资源）。
>
> 我们分两种情况讨论提交/执行阶段的过程：
>
> - 正常流程
>
> ![](https://raw.githubusercontent.com/KyrieJK/Figurebed/master/img/20191217153938.png)
>
> 1. 协调者节点向所有参与者发出全局提交（global commit）的请求；
> 2. 参与者节点正式完成事务提交操作，并释放在整个事务期间内占用的资源；
> 3. 参与者节点向协调者节点发送”ack“消息；
> 4. 协调者节点收到所有参与者节点反馈的”ack“消息后，完成事务；
> 5. 协调者就会向调用方返回分布式事务处理完成的结果。
>
> - 异常流程
>
> ![](https://raw.githubusercontent.com/KyrieJK/Figurebed/master/img/20191217155328.png)
>
> 相反，在第二阶段除了所有的参与者节点都反馈”我这边可以成功处理“的情况外，也会有节点反馈说”我这边不能处理“的情况或者协调者在第一阶段的询问超时之前无法获取所有参与者节点的响应消息的情况发生。此时参与者节点就会向协调者节点反馈”Vote Abort“的消息。此时协调者就会向所有的参与者节点发起事务回滚的消息（global rollback），此时各个参与者节点就会回滚本地事务，释放资源，并且向协调者节点发送”ack“确认消息，协调者节点就会向调用方返回分布式事务处理失败的结果。
>
> 无论最后结果如何，第二阶段都会结束当前事务。
>
> ### 两阶段提交存在的问题
>
> 两阶段提交看起来确实能够提供原子性的操作，但是还是有一些致命缺点需要我们注意：
>
> - **同步阻塞问题（性能问题**）：从流程上我们可以看出，其最大缺点就在于它的执行过程中间，各个节点都处于阻塞状态。各个操作数据库的节点此时都占用着数据库资源，只有当所有节点准备完毕，事务协调者才会通知进行全局提交，参与者进行本地事务提交后才会释放相应资源。这样其他第三方节点访问公共资源不得不处于阻塞状态，对性能影响比较大。
> - **参与者节点过多**：如果参与者节点变多了，协调者的工作效率会严重下降，整个流程也会变得十分复杂。
> - **协调者单点故障问题**：协调者是整个XA模型的核心，一旦协调者发生故障，参与者会一直阻塞下去。尤其在第二阶段，协调者发生故障，会导致参与者节点收不到提交或回滚的通知，从而导致参与者节点还处于锁定事务资源的状态中，始终处于事务无法完成的中间状态，而无法继续完成事务操作。如果再重新选举一个协调者，但是同样无法解决因为协调者宕机导致的参与者处于阻塞状态的问题。
> - **丢失消息导致的数据不一致问题**：在提交/执行阶段过程中，当协调者向参与者发送global commit请求之后，发生了局部网络异常或者在发送commit请求过程中协调者发生了故障，一部分参与者收到了global commit消息，另一部分事务参与者没有收到global commit消息。收到消息的参与者就会执行commit操作，但是其他未接收消息的机器则无法执行事务提交。于是整个分布式系统便出现了数据不一致的情况。
> - **两阶段无法解决的问题**：协调者在发出commit消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。即使协调者通过选举协议重新产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经被提交了。这时我们必须等待已经宕机的参与者恢复后，从参与者中查看事务的提交状态。这个问题既牵扯到了单点故障问题，也与性能问题相关。
>
> 既然两阶段提交的缺点有这么多，所以在两阶段提交的基础上做了改进，提出了三阶段提交协议。

## 三阶段提交

三阶段提交又称为3PC，其在两阶段提交的基础上增加了CanCommit阶段，并引入了超时机制。一旦参与者迟迟没有收到协调者的Commit请求，就会自动进行本地commit，而不是像两阶段提交协议中一直傻傻地等待。这样可以有效地解决协调者单点故障的问题。但是性能问题和不一致问题仍然没有得到根本解决。接下来还是一步一步的分析三阶段提交的过程。

### 第一阶段：CanCommit阶段

![](https://raw.githubusercontent.com/KyrieJK/Figurebed/master/img/20191217171454.png)

3PC类似于2PC中的准备阶段很像，是一种事务询问操作，事务的协调者向所有参与者询问”你们是否可以完成本次事务“。具体流程如下：

1. **事务询问**   协调者向参与者发送CanCommit请求。询问是否可以执行事务提交操作。然后开始等待参与者的响应。
2. **响应反馈**   参与者接到CanCommit请求之后，正常情况下，如果其自身认为可以顺利执行事务，则返回Yes响应，并进入预备状态。否则反馈No。

### 第二阶段：PreCommit阶段

![](https://raw.githubusercontent.com/KyrieJK/Figurebed/master/img/20191217172145.png)

协调者根据参与者的反馈情况来决定是否可以进行事务的PreCommit操作。根据响应情况，有以下两种可能。

假如协调者从所有的参与者获得的反馈都是Yes，那么就会执行事务的PreCommit。

1. 发送PreCommit  协调者向参与者发送PreCommit请求，并进入Prepared阶段。
2. 事务预提交  参与者接收到PreCommit请求后，会执行事务操作，并将undo和redo信息记录到事务日志中。
3. 响应反馈  如果参与者成功的执行了事务操作，则返回ACK响应，同时开始等待最终指令。

假如有任何一个参与者向协调者发送了No响应，或者等待超时后，协调者都没有接到参与者的响应，那么就执行事务的中断。

1. 发送中断请求  协调者向所有参与者发送abort请求。
2. 中断事务  参与者收到来自协调者的abort请求之后（或超时之后，仍未收到协调者的请求），执行事务的中断。

### 第三阶段：DoCommit阶段

![](https://raw.githubusercontent.com/KyrieJK/Figurebed/master/img/20191217173201.png)

在doCommit阶段真正的事务提交，也可以分为以下两种情况。

#### 执行提交

1. **发送提交请求**：协调者收到参与者发送的ACK响应，协调者会从Precommit状态进入到doCommit状态，并向所有参与者发送doCommit请求。
2. **事务提交**：参与者接收到doCommit请求之后，执行正式的事务提交。并在完成事务提交之后释放所有事务资源。
3. **响应反馈**：事务提交完之后，向协调者发送ACK响应。
4. **完成事务**：协调者接收到所有参与者的ACK响应之后，完成事务。

#### 中断事务

相反，如果有任意一个参与者节点未完成PreCommit的反馈或者反馈超时，那么协调者都会向所有的参与者节点发送abort请求，从而中断事务。

1. **发送中断请求**：协调者向所有参与者发送abort请求
2. **事务回滚**：参与者接收到abort请求之后，利用其在precommit阶段记录的undo信息来执行事务的回滚操作，并在完成回滚之后释放所有的事务资源。
3. **反馈结果**：参与者完成事务回滚之后，向协调者发送ACK消息。
4. **中断事务**：协调者接收到参与者反馈的ACK消息之后，执行事务的中断。

相比较2PC而言，3PC对于协调者和参与者都设置了超时时间，而2PC只有协调者才拥有超时机制。这个优化点主要避免了参与者在长时间无法与协调者通讯的情况下，无法释放资源的问题。

在doCommit阶段，如果参与者无法及时接收到来自协调者的doCommit或者abort请求时，会在等待超时之后，会继续进行事务的提交。这个决定是基于概率做出的。当进入doCommit阶段时，说明所有参与者节点在precommit阶段，都成功的执行了协调者发来的precommit请求。协调者产生precommit请求的前提条件是在CanCommit阶段，收到所有参与者的CanCommit响应都是Yes。因此当进入doCommit阶段时，由于网络异常等原因，虽然参与者没有收到commit或者abort请求，但是每个参与者根据前面阶段做出了判断：成功提交的几率是很大的。

3PC主要解决的单点故障造成的阻塞问题。因为一旦参与者无法及时收到来自协调者的信息之后，会默认执行commit，而不会一直持有事务资源并处于阻塞状态。但是这种机制同样也避免不了数据一致性问题、因为，由于网络原因，协调者发送的abort请求没有及时被参与者接收到，那么参与者在等待超时后会执行commit操作。这样就和其他接收到abort命令并执行回滚的参与者之间存在数据不一致的情况。

## 