

# 分布式系统基础理论(七)	副本控制协议

副本控制协议指按特定的协议流程控制副本数据的读写行为，使得副本满足一定的可用性和一致性要求的分布式协议。副本控制协议需要具备一定的容错能力，从而使得系统具有一定的可用性，同时副本控制协议要能提供一定的一致性级别。由CAP定理可知，具备强一致性、且在出现网络分区的情况下都可用的副本控制协议时不存在的。为此，实际中的副本控制协议需要在CA之间按照具体业务系统需求进行折中。

我们将副本控制协议分为两大类：“中心化副本控制协议”和“去中心化副本控制协议”。


   * [分布式系统基础理论(七)	副本控制协议](#分布式系统基础理论七副本控制协议)
      * [中心化副本控制协议](#中心化副本控制协议)
         * [primary-secondary协议](#primary-secondary协议)
            * [数据更新流程](#数据更新流程)
            * [数据读取方式](#数据读取方式)
            * [primary副本的确定与切换](#primary副本的确定与切换)
            * [数据同步](#数据同步)
      * [去中心化副本控制协议](#去中心化副本控制协议)


## 中心化副本控制协议

基本思路是由一个中心节点协议协调副本数据的更新、维护副本之间的一致性。下图给出了中心化副本协议的架构。这种协议比较简单，因为控制入口只有一个中心化节点，为我们节省了很多麻烦事情，所有副本的控制工作都交给中心节点完成就好啦。当出现多个节点同时需要修改副本数据时，需要解决“写写”、“读写”等并发冲突。单机系统上常用加锁等方式进行并发控制。对于分布式并发控制，加锁也是一个常用方法，但如果没有中心节点统一进行锁管理，就需要完全分布式化的锁系统，会使得协议非常复杂。中心化副本控制协议的缺点是系统的可用性强依赖于中心化节点，当中心化节点异常时或者与中心节点通信中断时，系统将失去某些服务，所以这种中心化副本控制协议的缺点是存在一定的停服务时间。

![](https://raw.githubusercontent.com/KyrieJK/Figurebed/master/img/20191201002527.png)

### primary-secondary协议

经典的中心化副本控制协议中最常用的叫做primary-secondary(primary-backup)中心化副本控制协议。在primary-secondary协议中，副本被分为两类，其中有且仅有一个副本作为primary副本，除primary以外的副本都作为secondary副本。维护primary副本的节点作为中心节点，中心节点负责维护数据更新、并发控制、协调副本的一致性。

primary-secondary协议需要解决四类问题：

- 数据更新流程
- 数据读取方式
- primary副本的确定和切换
- 数据同步（reconcile）

#### 数据更新流程

1. 数据更新均由primary节点协调完成
2. 外部节点将更新操作发送至primary节点
3. primary节点进行并发控制即确定并发更新操作的先后顺序
4. primary节点将更新操作发送给secondary节点
5. primary根据secondary节点的完成情况决定更新是否成功并将结果返回给外部节点

![](https://raw.githubusercontent.com/KyrieJK/Figurebed/master/img/20191201004225.png)

primary节点将更新操作发送到secondary节点时，同时也会发送更新的数据。如果有primary直接同时发送给其他N个副本发送数据，则每个secondary的更新吞吐受限于primary总的出口网络带宽，最大为primary网络出口带宽的1/N。为了解决这个问题，GFS使用接力的方式同步数据，即primary将更新发送给第一个secondary副本，第一个secondary发送给第二个secondary副本，依次类推。由于节点可能发生异常，因此第4步可能会在有些副本上失败，有些副本上超时。不同的副本控制协议对这一步的异常处理是不同的。后面会再继续讨论这个问题。

#### 数据读取方式

数据读取与副本一致性息息相关。如果只需要最终一致性，那么读取任何副本都可以满足需求。如果需要会话一致性，则可以为副本设置版本号，每次更新后递增版本号，用户读取副本时验证版本号，从而保证用户读到的数据在会话范围内单调递增。使用primary-secondary很难实现强一致性。

实现强一致性有几个思路：

1. 由于数据的更新流程都是由primary节点控制，所以primary上面的数据肯定是最新的，如果始终只读取primary副本上的数据，就可以直接实现强一致性。但是其实这种方法属于掩耳盗铃，相当于整个分布式系统的读服务压力都到了primary节点上，一旦primary出现异常，整个分布式系统的读服务就挂掉了，可用性很差。在工程实践中，如果副本不与机器绑定，而是按照数据段为单位维护副本，仅有primary副本提供读服务在很多场景下并不会造成机器资源浪费。将数据分为数据段，以数据段为副本的基本单位，将副本分散到集群中，假设primary是随机确定的，那么每台机器上都有可能包含primary副本，也包含另一些数据段的secondary副本，从而某台服务器实际都提供读写服务。

   假设某系统中的数据有3个数据段，o、p、q，每个数据段都有三个副本，其中有一个primary副本。系统共有4台机器，第一台机器上有数据段o（primary）、p、q，第二台机器上有数据段o、p（primary），第三台机器上有数据段p、o，第四台机器上有数据段q（primary）、o。从这个例子中可以看到，只要primary副本分散到集群中，即使只有primary副本提供读写服务，也可以充分利用集群机器资源。

2. 由primary控制secondary节点的可用性。当primary更新某个secondary副本不成功时，primary将该secondary副本标记为不可用，从而用户不再读取该不可用的副本。不可用的secondary副本持续尝试与primary同步数据，当与primary完成数据同步后，primary将secondary副本标记为可用。这种使得所有可用的副本，无论是primary还是secondary都可以提供读服务，且在一个确定的时间内，某secondary副本要么更新到与primary一致，要么被标记为不可用，从而符合较高的一致性要求。这种方式依赖于一个中心元数据管理系统，用于记录哪些副本可用，哪些不可用。这种思路是通过降低系统可用性而提高系统的一致性。

3. 基于Quorum机制，后面会详细讲。

#### primary副本的确定与切换

这类协议的核心问题时如何确定primary副本，并且在原primary副本所在机器出现异常时，需要有一种机制支持primary副本切换，使得某个secondary成为新的primary副本。

在primary-secondary协议的分布式系统中，哪个副本是primary这一信息属于元信息，由专门的元数据服务器维护。执行更新操作时，首先查询元数据服务器获取副本的primary信息，从而进一步执行数据更新流程。

切换副本的难点在于两个方面：

- 如何确定节点的状态以发现原primary节点异常是一个比较复杂的问题。后面会介绍一种基于Lease机制确定节点状态的方法。
- 切换primary后，不能影响副本的一致性。尤其是提供较强一致性服务的系统，切换primary的影响更是需要控制。

要达到这个目的，直接的思路是切换的新primary的副本数据必须与原primary的副本一致。然而在原primary已经发送宕机等异常时，如何确定一个secondary副本使得该副本上的数据与原primary一致又成为新的问题。这个问题其实和之前提到的选择一个secondary副本上读取最新的数据是一个等价问题。

由于分布式系统中可靠的发现节点异常是需要一定的探测时间的，这样的探测时间通常是10s级别，这也意味着一旦primary异常，最多需要10s的发现时间，系统才能开始primary副本的切换，在这10s时间内，由于没有primary副本，系统不能提供更新服务，如果系统只能读primary副本，则这段时间内甚至不能提供读服务。所以primary-backup协议最大的问题就是由于primary切换带来的一定时间内的停服务问题。

#### 数据同步

primary-secondary协议通常会遇到secondary副本与primary副本数据不一致的问题。此时不一致的secondary副本需要与primary副本进行数据同步。

通常数据不一致的形式有三种：

1. 由于网络分区等异常，secondary上的数据落后于primary上的数据。
2. 在某些协议下，secondary上的数据有可能是脏数据，需要被丢弃。“脏数据”是由于primary副本没有进行某一更新操作，而secondary副本上反而进行的多余的修改操作，从而造成secondary副本数据错误。
3. secondary是一个新增加的副本，完全没有数据，需要从其他副本上拷贝数据。

对于第一种secondary数据落后的情况，常见的同步方式是回放primary上的操作日志，从而追上primary的更新进度。对于脏数据的情况，常见的做法是设计的分布式协议不产生脏数据。如果协议一定有产生脏数据的可能，则也应该使得产生脏数据的概率降到非常低的情况，从而一旦发生脏数据的情况可以简单的直接丢弃有脏数据的副本，这样相当于副本没有数据。另外，也可以设计一些基于undo日志的方式从而可以直接删除脏数据。如果secondary副本完全没有数据，则常见的做法是直接拷贝primary副本的数据，这种方法往往比回放日志追更新进度的方法快很多。但是拷贝数据时primary副本需要能够继续提供更新服务，这就要求primary副本支持快照功能。即对某一时刻的副本数据形成快照，然后拷贝快照，拷贝完成后使用回放日志的方式追快照形成后的更新操作。

## 去中心化副本控制协议

与中心化副本系统协议最大的不同是，去中心化副本协议没有中心节点，协议总所有的节点都是完全对等的，节点之间通过vote达成一致。从而去中心化协议没有因为中心化节点异常而带来的停服务等问题。

![](https://raw.githubusercontent.com/KyrieJK/Figurebed/master/img/20191201212916.png)

但是所带来的问题是协议比较复杂，工程上不容易实现。尤其当去中心化协议需要实现强一致性时，协议流程变得复杂且不容易理解。由于流程复杂，去中心化协议的效率或者性能一般也比中心化协议稍低。

总结一下就是中心化副本控制协议类比于中央集权制度，系统效率高但是十分依赖中心节点，一旦中心节点异常，系统受到的影响会很大；去中心化副本控制协议类比于民主制度，节点集体协商，效率低下，但是个别节点的异常不会对系统整体可用性造成严重的影响。

